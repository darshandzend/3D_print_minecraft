#!/bin/env python3
import math
import time
import subprocess
import argparse

from os import system

# Defaults
SUBSTANCE = 'smooth_stone'
# Offsets determine the origin point (0,0,0) in 3D space
x_offset = 8
y_offset = 8
z_offset = 5
height = 60
length = int(height/2)
bredth = int(height/2)

# Parse args
parser = argparse.ArgumentParser(description='Generate Minecraft structure.')
parser.add_argument('--substance', dest='substance',
                    help='Minecraft substance ID (default: '+SUBSTANCE+')')
parser.add_argument('--erase', dest='erase', action='store_true',
                    help='Erase structure generated by function (same as substance=air)')
args = parser.parse_args()
if args.substance:
    SUBSTANCE  = args.substance
if args.erase:
    SUBSTANCE = 'air'

def main():
    fill_structure()

# This is the function which actually defines the 3D shape
# Change this according to your needs
#TODO: Externalisation
def fill_structure():
    # The shape is a stack of squares on top of each other.
    # The size of these squares reduces with height
    # The center of these squares shifts rightwards parabolically

    last_y = 0
    for z in range(height):
        size = size_of_square_at(z)
        if size > 0:
            base_center = center_of_square_at(z)
            #square(size,center)
            room(size,4,base_center)
            # Pillars
            for y in range(min(last_y,base_center[1]), max(last_y,base_center[1])):
                if y > -48 and y%4 == 0:
                    print(y)
                    fill(0, y, 0, 0, y, base_center[2],'quartz_pillar')
            last_y = base_center[1]

    # Hollow out
    for z in range(height):
        size = size_of_square_at(z)
        if size > 0:
            base_center = center_of_square_at(z)
            #square(size,center)
            hollow(size,4,base_center)


def size_of_square_at(z):
    # https://www.desmos.com/calculator/otgqse2aqs
    side = round(math.sqrt( 80**2 - z**2) ) - 60
    return side if side > 0 else 0

def center_of_square_at(z):
    # https://www.desmos.com/calculator/p3jcvetpdm
    shift = round(math.sqrt( 52**2 - z**2) ) - 52
    return (0,shift,z)

def room(side, height, center):
    half = int(side/2)
    h = height-1
    # Create solid cuboid
    fill(
        center[0]-half, center[1]-half, center[2],
        center[0]+half, center[1]+half, center[2]+h,
    )
def hollow(side,height,center):
    half = int(side/2)
    h = height-1
    # Hollow it out by creating an air cuboid inside
    fill(
        center[0]-half+1, center[1]-half+1, center[2]+1,
        center[0]+half-1, center[1]+half-1, center[2]+h-1,
        'air'
    )


def radius_at_level(z):
    # Tip: To picture this curve better, just rotate your imaginary x-y axis
    # such that 'z' variable is horizontal, growing rightwards

    #return math.floor( math.sqrt ( 5**2 - z**2 ) )  # Circle
    x = height-z
    return round( math.sqrt( 5*x ) ) # Parabola

# ---------------------------------


# ---- Utilities --------------
def moved(matrix, distance):
    # Moves a given 2D matrix w.r.t origin by a given distance
    # Returns a new matrix
    filled = [ [ False for _ in range(length) ] for _ in range(bredth) ]
    for y,row in enumerate(matrix):
        for x,_ in enumerate(row):
            if (x+distance) < length and (y+distance) < bredth:
                filled[y+distance][x+distance] = matrix[y][x]
    return filled

# ---------------------------------


# ---- Common Shapes --------------
def square(side, center):
    if side > 0:
        half = int(side/2)
        fill(
            center[0]-half, center[1]-half, center[2],
            center[0]+half, center[1]+half, center[2],
        )


def draw_circle(r, center):
    shift_x = center[0]
    shift_y = center[1]
    z = center[2]
    prev_y = r
    for x in range(r+1):
        y = math.floor( math.sqrt( (r**2) - ((x)**2)) )
        plot_point(x+shift_x,y+shift_y,z)
        plot_point(x+shift_x,-y+shift_y,z)
        plot_point(-x+shift_x,y+shift_y,z)
        plot_point(-x+shift_x,-y+shift_y,z)
        # Fill empty x spaces if the y jump is too steep
        if prev_y - y > 1:
            for fill_y in range(y+1, prev_y):
                plot_point(x-1+shift_x,fill_y+shift_y,z)
                plot_point(x-1+shift_x,-fill_y+shift_y,z)
                plot_point(-x+1+shift_x,fill_y+shift_y,z)
                plot_point(-x+1+shift_x,-fill_y+shift_y,z)
        prev_y = y

def circle_radial(r, center):
    shift_x = center[0]
    shift_y = center[1]
    z = center[2]
    for theta in range(0,361):
        print(theta)
        x = round(r * math.cos(math.radians(theta)))
        y = round(r * math.sin(math.radians(theta)))
        plot_point(x,y,z)

# ---------------------------------


# ---- Core Utility functions -----
def plot_point(x,y,z,substance=SUBSTANCE):
    fill(x, y, z, x, y, z, substance)

def fill(x1, y1, z1, x2, y2, z2, substance=SUBSTANCE):
    if args.erase:
        substance = 'air'
    x1 += x_offset
    x2 += x_offset
    y1 += y_offset
    y2 += y_offset
    z1 += z_offset
    z2 += z_offset
    send_cmd("fill {} {} {} {} {} {} {}".format(x1, z1, y1, x2, z2, y2, substance))

def send_cmd(cmd):
    print(cmd)
    cmd = cmd + "\\n"
    subprocess.call(["screen", "-S", "minecraft", "-X", "stuff", "{}".format(cmd)])

    #input("")
# ---------------------------------


# ---- Debug helpers --------------
def print_2d(array_2d):
    print("Rows: ",len(array_2d))
    for y in reversed(array_2d):
        line = ""
        for x in y:
            if(x):
                line += "■"
            else:
                line += "·"
        print(line)

main()
