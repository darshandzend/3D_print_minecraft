#!/bin/env python3
import math
import time
import subprocess
import argparse

from os import system

# Defaults
SUBSTANCE = 'smooth_stone'
# Offsets determine the origin point (0,0,0) in 3D space
x_offset = 8
y_offset = 8
z_offset = 5
height = 60
length = int(height/2)
bredth = int(height/2)

# Parse args
parser = argparse.ArgumentParser(description='Generate Minecraft structure.')
parser.add_argument('--substance', dest='substance',
                    help='Minecraft substance ID (default: '+SUBSTANCE+')')
parser.add_argument('--erase', dest='erase', action='store_true',
                    help='Erase structure generated by function (same as substance=air)')
args = parser.parse_args()
if args.substance:
    SUBSTANCE  = args.substance
if args.erase:
    SUBSTANCE = 'air'

def main():
    # Clear area
    fill(0,0,0,length,bredth,height,'air')
    fill(0,0,0,-length,bredth,height,'air')
    fill(0,0,0,length,-bredth,height,'air')
    fill(0,0,0,-length,-bredth,height,'air')

    fill_structure()

# This is the function which actually defines the 3D shape
# Change this according to your needs
#TODO: Externalisation
def fill_structure():
    # The shape is a stack of squares on top of each other.
    # The size of these squares reduces with height
    # The center of these squares shifts rightwards parabolically

    last_x = 0
    for z in range(height):
        size = size_of_square_at(z)
        if size > 0:
            center = center_of_square_at(z)
            square(size,center)
            print(last_x)
            # Pillars
            if size > 1:
                for x in range(min(last_x,center[0]), max(last_x,center[0])):
                    if x%4 == 0:
                        print("pillar", x)
                        fill(x, x, 0, x, x, center[2])
            last_x = center[0]


def size_of_square_at(z):
    # https://www.desmos.com/calculator/otgqse2aqs
    side = round(math.sqrt( 80**2 - z**2) ) - 60
    return side if side > 0 else 0

def center_of_square_at(z):
    # https://www.desmos.com/calculator/p3jcvetpdm
    shift = round(math.sqrt( 52**2 - z**2) ) - 52
    return (shift,shift,z)

def radius_at_level(z):
    # Tip: To picture this curve better, just rotate your imaginary x-y axis
    # such that 'z' variable is horizontal, growing rightwards

    #return math.floor( math.sqrt ( 5**2 - z**2 ) )  # Circle
    x = height-z
    return round( math.sqrt( 5*x ) ) # Parabola

# ---------------------------------


# ---- Utilities --------------
def moved(matrix, distance):
    # Moves a given 2D matrix w.r.t origin by a given distance
    # Returns a new matrix
    filled = [ [ False for _ in range(length) ] for _ in range(bredth) ]
    for y,row in enumerate(matrix):
        for x,_ in enumerate(row):
            if (x+distance) < length and (y+distance) < bredth:
                filled[y+distance][x+distance] = matrix[y][x]
    return filled

# ---------------------------------


# ---- Common Shapes --------------
def square(side, center):
    if side > 0:
        half = int(side/2)
        fill(
            center[0]-half, center[1]-half, center[2],
            center[0]+half, center[1]+half, center[2],
          )


def draw_circle(r, center):
    shift_x = center[0]
    shift_y = center[1]
    z = center[2]
    prev_y = r
    for x in range(r+1):
        y = math.floor( math.sqrt( (r**2) - ((x)**2)) )
        plot_point(x+shift_x,y+shift_y,z)
        plot_point(x+shift_x,-y+shift_y,z)
        plot_point(-x+shift_x,y+shift_y,z)
        plot_point(-x+shift_x,-y+shift_y,z)
        # Fill empty x spaces if the y jump is too steep
        if prev_y - y > 1:
            for fill_y in range(y+1, prev_y):
                plot_point(x-1+shift_x,fill_y+shift_y,z)
                plot_point(x-1+shift_x,-fill_y+shift_y,z)
                plot_point(-x+1+shift_x,fill_y+shift_y,z)
                plot_point(-x+1+shift_x,-fill_y+shift_y,z)
        prev_y = y

def circle_radial(r, center):
    shift_x = center[0]
    shift_y = center[1]
    z = center[2]
    for theta in range(0,361):
        print(theta)
        x = round(r * math.cos(math.radians(theta)))
        y = round(r * math.sin(math.radians(theta)))
        plot_point(x,y,z)

# ---------------------------------


# ---- Core Utility functions -----
def plot_point(x,y,z,substance=SUBSTANCE):
    fill(x, y, z, x, y, z, substance)

def fill(x1, y1, z1, x2, y2, z2, substance=SUBSTANCE):
    x1 += x_offset
    x2 += x_offset
    y1 += y_offset
    y2 += y_offset
    z1 += z_offset
    z2 += z_offset
    send_cmd("fill {} {} {} {} {} {} {}".format(x1, z1, y1, x2, z2, y2, substance))

def send_cmd(cmd):
    print(cmd)
    cmd = cmd + "\\n"
    subprocess.call(["screen", "-S", "minecraft", "-X", "stuff", "{}".format(cmd)])

    #input("")
# ---------------------------------


# ---- Debug helpers --------------
def print_2d(array_2d):
    print("Rows: ",len(array_2d))
    for y in reversed(array_2d):
        line = ""
        for x in y:
            if(x):
                line += "■"
            else:
                line += "·"
        print(line)

main()
